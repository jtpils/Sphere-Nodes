function [x, tri]= getOctNodes(k)
%%GETOCTNODES Computes the equal area octahedral node sets for the surface of the sphere.
%
%   X = getOctNodes(k) returns an N-by-3 matrix containing the 
%   octahedral node set, where the columns corresponds to the (x,y,z) 
%   coordinates of the nodes.  Note that these nodes are only
%   unique up to a roataion.
%
%   The nodes are generated by k levels of refinement of the 8 spherical
%   triangles that form the base octahedron.  Each new refined level of
%   triangles is generated by bisecting the edges of the triangles on the
%   current level.  This gives the following total number of nodes on the
%   sphere: 
%                            N = 4k^2+2
%   [X,tri] returns a triangulation of the nodes

%   Author T. Michaels

%   [1] A. Holhos and D. Rosca. An Octahedral Equal Area Partition of the
%   Sphere and Near Optimal Configurations of Points. Comput. Math. Appl.
%   67 1092-1107, 2014

%%  Here are the nodes for the base octaahedron of area 4*pi
L = sqrt(2*pi/sqrt(3));
R = L/sqrt(2);
x = [[0,0,R];[0,0,-R];[0,R,0];[0,-R,0];[R,0,0];[-R,0,0]];


vert = [0, 0, R; 0,0, -R];
% Face 1
h = 3; % H will index vert
p1 = 1/k.*[-R, R, 0];
q1 = 1/k.*[-R, 0, R];
for i = 0:k-1
    for j = 0: k-1-i
        vert(h,:) = [R, 0, 0] + i.*p1 +j.*q1;
        h = h+1;
    end
end

%Face 2
p2 = 1/k.*[-R, -R, 0];
q2 = 1/k.*[0, -R, R];
for i = 0:k-1
    for j = 0: k-1-i
        vert(h,:) = [0, R, 0] + i.*p2 +j.*q2;
        h = h+1;
    end
end

%Face 3
p3 = 1/k.*[R, -R, 0];
q3 = 1/k.*[R, 0, R];
for i = 0:k-1
    for j = 0: k-1-i
        vert(h,:) = [-R, 0, 0] + i.*p3 +j.*q3;
        h = h+1;
    end
end

%Face 4
p4 = 1/k.*[R, R, 0];
q4 = 1/k.*[0, R, R];
for i = 0:k-1
    for j = 0: k-1-i
        vert(h,:) = [0, -R, 0] + i.*p4 +j.*q4;
        h = h+1;
    end
end

% Face 5
p5 = 1/k.*[-R, R, 0];
q5 = 1/k.*[-R, 0, -R];
for i = 0:k-1
    for j = 1: k-1-i
        vert(h,:) = [R, 0, 0] + i.*p5 +j.*q5;
        h = h+1;
    end
end

%Face 6
p6 = 1/k.*[-R, -R, 0];
q6 = 1/k.*[0, -R, -R];
for i = 0:k-1
    for j = 1: k-1-i
        vert(h,:) = [0, R, 0] + i.*p6 +j.*q6;
        h = h+1;
    end
end

%Face 7
p7 = 1/k.*[R, -R, 0];
q7 = 1/k.*[R, 0, -R];
for i = 0:k-1
    for j = 1: k-1-i
        vert(h,:) = [-R, 0, 0] + i.*p7 +j.*q7;
        h = h+1;
    end
end

%Face 8
p8 = 1/k.*[R, R, 0];
q8 = 1/k.*[0, R, -R];
for i = 0:k-1
    for j = 1: k-1-i
        vert(h,:) = [0, -R, 0] + i.*p8 +j.*q8;
        h = h+1;
    end
end

% Project the nodes to the sphere using area preserving projection.
x = vert;
[sizex, n1] = size(x);
y = zeros(sizex,3);
for i=1:sizex
y(i,3) = 2*x(i,3)/L^2*(sqrt(2)*L-abs(x(i,3)));
if (x(i,2)==0)
    y(i,2) = 0;
    y(i,1) = sign(x(i,1))*sqrt(1-y(i,3)^2);
else

y(i,1) = sign(x(i,1))*sqrt(1-y(i,3)^2)*cos(x(i,2)*pi/(2*(sign(x(i,2)*x(i,1))*x(i,1)+x(i,2))));
y(i,2) = sign(x(i,2))*sqrt(1-y(i,3)^2)*sin(x(i,2)*pi/(2*(sign(x(i,2)*x(i,1))*x(i,1)+x(i,2))));
end
end
x = y;
%Triangulate the nodes
tri = delaunay(x);
tri = freeBoundary(TriRep(tri,x));
end
